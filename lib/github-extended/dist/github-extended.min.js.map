{"version":3,"sources":["github-extended.js","github-extended.min.js"],"names":["_typeof","obj","Symbol","constructor","global","factory","define","amd","exports","require","mod","Github","this","_githubApi","_interopRequireDefault","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","_githubApi2","_GithubApi","options","_this","getPrototypeOf","superGetRepo","getRepo","request","_request","user","repo","getRepositoryInfo","repository","Promise","resolve","reject","show","error","superRemove","remove","superFork","fork","search","string","arguments","length","undefined","FILE","FOLDER","assign","branch","caseSensitive","excludeFiles","excludeFolders","getSha","sha","then","getTree","list","regex","RegExp","filter","content","fileCondition","type","folderCondition","extractName","path","substring","lastIndexOf","test","mergePullRequest","pullRequest","commitMessage","number","repositoryInfo","full_name","commit_message","head","mergeInfo","removeFile","branchName","removeFolder","getRef","tree","filesPromises","item","indexOf","map","forEach","replace","removeFilePromise","err","forkInfo","pollFork","contents","setTimeout","bind","username"],"mappings":"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","file":"github-extended.min.js","sourcesContent":["'use strict';\n\nimport GithubApi from 'github-api';\n\n/**\n * The class that extends Github.js\n *\n * @extends GithubApi\n */\nexport\n default class Github extends GithubApi {\n   /**\n    * @constructor\n    * @param {Object} options The object containing the information to work with the GitHub API\n    * @param {string} options.username The username used on GitHub\n    * @param {string} options.password The password of the GitHub account\n    * @param {string} options.auth The type of authentication to use. It can be either `basic` or `oauth`\n    * @param {string} options.token The token to access the GitHub API\n    */\n   constructor(options) {\n      super(options);\n\n      let superGetRepo = this.getRepo;\n      let request = this.request || this._request; // jscs:ignore disallowDanglingUnderscores\n\n      /**\n       * Returns an object representing a specific repository\n       *\n       * @param {string} user The username that possesses the repository\n       * @param {string} repo The name of the repository to work on\n       *\n       * @returns {Object}\n       */\n      this.getRepo = (user, repo) => {\n         let repository = superGetRepo(user, repo);\n         let superRemove = repository.remove;\n         let superFork = repository.fork;\n\n         function getRepositoryInfo(repository) {\n            return new Promise((resolve, reject) => {\n               repository.show((error, repo) => {\n                  if (error) {\n                     reject(error);\n                  }\n\n                  resolve(repo);\n               });\n            });\n         }\n\n         /**\n          * Searches files and folders\n          *\n          * @param {string} string The string to search\n          * @param {Object} [options={}] Possible options\n          * @param {string} [options.branch] The name of the branch in which the search must be performed\n          * @param {boolean} [options.caseSensitive=false] If the search must be case sensitive\n          * @param {boolean} [options.excludeFiles=false] If the result must exclude files\n          * @param {boolean} [options.excludeFolders=false] If the result must exclude folders\n          *\n          * @returns {Promise}\n          */\n         repository.search = (string, options = {}) => {\n            const FILE = 'blob';\n            const FOLDER = 'tree';\n\n            options = Object.assign({\n               branch: 'master',\n               caseSensitive: false,\n               excludeFiles: false,\n               excludeFolders: false\n            }, options);\n\n            return new Promise((resolve, reject) => {\n               repository.getSha(options.branch, '', (error, sha) => {\n                  if (error) {\n                     reject(error);\n                  }\n\n                  resolve(sha);\n               });\n            })\n               .then(sha => {\n                  return new Promise((resolve, reject) => {\n                     repository.getTree(`${sha}?recursive=true`, (error, list) => {\n                        if (error) {\n                           // No matches\n                           if (error.error === 404) {\n                              resolve([]);\n                           } else {\n                              reject(error);\n                           }\n                        }\n\n                        resolve(list);\n                     });\n                  });\n               })\n               .then(list => {\n                  let regex = new RegExp(string, options.caseSensitive ? '' : 'i');\n\n                  return list.filter(content => {\n                     let fileCondition = options.excludeFiles ? content.type !== FILE : true;\n                     let folderCondition = options.excludeFolders ? content.type !== FOLDER : true;\n                     let extractName = (path) => path.substring(path.lastIndexOf('/') + 1);\n\n                     return fileCondition && folderCondition && regex.test(extractName(content.path));\n                  });\n               });\n         };\n\n         /**\n          * Merges a pull request\n          *\n          * @param {Object} pullRequest The pull request to merge\n          * @param {Object} [options={}] Possible options\n          * @param {string} [options.commitMessage] The commit message for the merge\n          *\n          * @returns {Promise}\n          */\n         repository.mergePullRequest = (pullRequest, options = {}) => {\n            options = Object.assign(\n               {\n                  commitMessage: `Merged pull request gh-${pullRequest.number}`\n               },\n               options\n            );\n\n            return getRepositoryInfo(repository)\n               .then(repositoryInfo => {\n                  return new Promise((resolve, reject) => {\n                     request(\n                        'PUT',\n                        `/repos/${repositoryInfo.full_name}/pulls/${pullRequest.number}/merge`, // jscs:ignore\n                        {\n                           commit_message: options.commitMessage, // jscs:ignore\n                           sha: pullRequest.head.sha\n                        },\n                        (error, mergeInfo) => {\n                           if (error) {\n                              reject(error);\n                           }\n\n                           resolve(mergeInfo);\n                        }\n                     );\n                  });\n               });\n         };\n\n         /**\n          * Deletes a file or a folder and all of its content from a given branch\n          *\n          * @param {string} [branchName='master'] The name of the branch in which the deletion must be performed\n          * @param {string} [path=''] The path of the file or the folder to delete\n          *\n          * @returns {Promise}\n          */\n         repository.remove = (branchName = 'master', path = '') => {\n            function removeFile(branchName, path) {\n               return new Promise((resolve, reject) => {\n                  superRemove(branchName, path, error => {\n                     if (error) {\n                        reject(error);\n                     }\n\n                     resolve();\n                  });\n               });\n            }\n\n            function removeFolder() {\n               return new Promise((resolve, reject) => {\n                  repository.getRef(`heads/${branchName}`, (error, sha) => {\n                     if (error) {\n                        reject(error);\n                     }\n\n                     resolve(sha);\n                  });\n               })\n                  .then(sha => {\n                     return new Promise((resolve, reject) => {\n                        repository.getTree(`${sha}?recursive=true`, (error, tree) => {\n                           if (error) {\n                              reject(error);\n                           }\n\n                           resolve(tree);\n                        });\n                     });\n                  })\n                  .then(tree => {\n                     let filesPromises = Promise.resolve();\n\n                     // Filters all items that aren't in the path of interest and aren't files\n                     // and delete them.\n                     tree\n                        .filter(item => item.path.indexOf(path) === 0 && item.type === 'blob')\n                        .map(item => item.path)\n                        .forEach(path => {\n                           filesPromises = filesPromises.then(() => removeFile(branchName, path));\n                        });\n\n                     return filesPromises;\n                  });\n            }\n\n            // Remove any trailing slash from the path.\n            // GitHub does not accept it even when dealing with folders.\n            path = path.replace(/\\/$/, '');\n\n            let removeFilePromise = removeFile(branchName, path);\n\n            return removeFilePromise\n               .then(\n                  () => removeFilePromise,\n                  error => {\n                     // If the operation fails because the path specified is that of a folder\n                     // keep going to retrieve the files recursively\n                     if (error.error !== 422) {\n                        throw error;\n                     }\n\n                     return removeFolder();\n                  });\n         };\n\n         /**\n          * Creates a fork of the repository\n          *\n          * @returns {Promise}\n          */\n         repository.fork = () => {\n            return new Promise((resolve, reject) => {\n               superFork((err, forkInfo) => {\n                  function pollFork(fork) {\n                     fork.contents('master', '', (err, contents) => {\n                        if (contents) {\n                           resolve(forkInfo);\n                        } else {\n                           setTimeout(pollFork.bind(null, fork), 250);\n                        }\n                     });\n                  }\n\n                  if (err) {\n                     reject(err);\n                  } else {\n                     pollFork(superGetRepo(options.username, repo));\n                  }\n               });\n            });\n         };\n\n         return repository;\n      };\n   }\n}","'use strict';\n\nfunction _typeof(obj) { return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }\n\n(function (global, factory) {\n   if (typeof define === \"function\" && define.amd) {\n      define('Github', ['exports', 'github-api'], factory);\n   } else if (typeof exports !== \"undefined\") {\n      factory(exports, require('github-api'));\n   } else {\n      var mod = {\n         exports: {}\n      };\n      factory(mod.exports, global.Github);\n      global.Github = mod.exports;\n   }\n})(this, function (exports, _githubApi) {\n   Object.defineProperty(exports, \"__esModule\", {\n      value: true\n   });\n\n   var _githubApi2 = _interopRequireDefault(_githubApi);\n\n   function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n         default: obj\n      };\n   }\n\n   function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) {\n         throw new TypeError(\"Cannot call a class as a function\");\n      }\n   }\n\n   function _possibleConstructorReturn(self, call) {\n      if (!self) {\n         throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      }\n\n      return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n   }\n\n   function _inherits(subClass, superClass) {\n      if (typeof superClass !== \"function\" && superClass !== null) {\n         throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n      }\n\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n         constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n         }\n      });\n      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n   }\n\n   var Github = (function (_GithubApi) {\n      _inherits(Github, _GithubApi);\n\n      function Github(options) {\n         _classCallCheck(this, Github);\n\n         var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Github).call(this, options));\n\n         var superGetRepo = _this.getRepo;\n         var request = _this.request || _this._request;\n\n         _this.getRepo = function (user, repo) {\n            var repository = superGetRepo(user, repo);\n            var superRemove = repository.remove;\n            var superFork = repository.fork;\n\n            function getRepositoryInfo(repository) {\n               return new Promise(function (resolve, reject) {\n                  repository.show(function (error, repo) {\n                     if (error) {\n                        reject(error);\n                     }\n\n                     resolve(repo);\n                  });\n               });\n            }\n\n            repository.search = function (string) {\n               var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n               var FILE = 'blob';\n               var FOLDER = 'tree';\n               options = Object.assign({\n                  branch: 'master',\n                  caseSensitive: false,\n                  excludeFiles: false,\n                  excludeFolders: false\n               }, options);\n               return new Promise(function (resolve, reject) {\n                  repository.getSha(options.branch, '', function (error, sha) {\n                     if (error) {\n                        reject(error);\n                     }\n\n                     resolve(sha);\n                  });\n               }).then(function (sha) {\n                  return new Promise(function (resolve, reject) {\n                     repository.getTree(sha + '?recursive=true', function (error, list) {\n                        if (error) {\n                           if (error.error === 404) {\n                              resolve([]);\n                           } else {\n                              reject(error);\n                           }\n                        }\n\n                        resolve(list);\n                     });\n                  });\n               }).then(function (list) {\n                  var regex = new RegExp(string, options.caseSensitive ? '' : 'i');\n                  return list.filter(function (content) {\n                     var fileCondition = options.excludeFiles ? content.type !== FILE : true;\n                     var folderCondition = options.excludeFolders ? content.type !== FOLDER : true;\n\n                     var extractName = function extractName(path) {\n                        return path.substring(path.lastIndexOf('/') + 1);\n                     };\n\n                     return fileCondition && folderCondition && regex.test(extractName(content.path));\n                  });\n               });\n            };\n\n            repository.mergePullRequest = function (pullRequest) {\n               var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n               options = Object.assign({\n                  commitMessage: 'Merged pull request gh-' + pullRequest.number\n               }, options);\n               return getRepositoryInfo(repository).then(function (repositoryInfo) {\n                  return new Promise(function (resolve, reject) {\n                     request('PUT', '/repos/' + repositoryInfo.full_name + '/pulls/' + pullRequest.number + '/merge', {\n                        commit_message: options.commitMessage,\n                        sha: pullRequest.head.sha\n                     }, function (error, mergeInfo) {\n                        if (error) {\n                           reject(error);\n                        }\n\n                        resolve(mergeInfo);\n                     });\n                  });\n               });\n            };\n\n            repository.remove = function () {\n               var branchName = arguments.length <= 0 || arguments[0] === undefined ? 'master' : arguments[0];\n               var path = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\n               function removeFile(branchName, path) {\n                  return new Promise(function (resolve, reject) {\n                     superRemove(branchName, path, function (error) {\n                        if (error) {\n                           reject(error);\n                        }\n\n                        resolve();\n                     });\n                  });\n               }\n\n               function removeFolder() {\n                  return new Promise(function (resolve, reject) {\n                     repository.getRef('heads/' + branchName, function (error, sha) {\n                        if (error) {\n                           reject(error);\n                        }\n\n                        resolve(sha);\n                     });\n                  }).then(function (sha) {\n                     return new Promise(function (resolve, reject) {\n                        repository.getTree(sha + '?recursive=true', function (error, tree) {\n                           if (error) {\n                              reject(error);\n                           }\n\n                           resolve(tree);\n                        });\n                     });\n                  }).then(function (tree) {\n                     var filesPromises = Promise.resolve();\n                     tree.filter(function (item) {\n                        return item.path.indexOf(path) === 0 && item.type === 'blob';\n                     }).map(function (item) {\n                        return item.path;\n                     }).forEach(function (path) {\n                        filesPromises = filesPromises.then(function () {\n                           return removeFile(branchName, path);\n                        });\n                     });\n                     return filesPromises;\n                  });\n               }\n\n               path = path.replace(/\\/$/, '');\n               var removeFilePromise = removeFile(branchName, path);\n               return removeFilePromise.then(function () {\n                  return removeFilePromise;\n               }, function (error) {\n                  if (error.error !== 422) {\n                     throw error;\n                  }\n\n                  return removeFolder();\n               });\n            };\n\n            repository.fork = function () {\n               return new Promise(function (resolve, reject) {\n                  superFork(function (err, forkInfo) {\n                     function pollFork(fork) {\n                        fork.contents('master', '', function (err, contents) {\n                           if (contents) {\n                              resolve(forkInfo);\n                           } else {\n                              setTimeout(pollFork.bind(null, fork), 250);\n                           }\n                        });\n                     }\n\n                     if (err) {\n                        reject(err);\n                     } else {\n                        pollFork(superGetRepo(options.username, repo));\n                     }\n                  });\n               });\n            };\n\n            return repository;\n         };\n\n         return _this;\n      }\n\n      return Github;\n   })(_githubApi2.default);\n\n   exports.default = Github;\n});"],"sourceRoot":"/source/"}